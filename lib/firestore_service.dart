import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:youtube_explode_dart/youtube_explode_dart.dart';
import 'packagepackage:music_player/youtube_link_model.dart';

class FirestoreService {
  final FirebaseFirestore _db = FirebaseFirestore.instance;
  late final CollectionReference<YoutubeLink> _linksRef;

  FirestoreService() {
    _linksRef = _db.collection('youtube_links').withConverter<YoutubeLink>(
          fromFirestore: YoutubeLink.fromFirestore,
          toFirestore: (YoutubeLink link, _) => link.toFirestore(),
        );
  }

  Future<void> addLink(String userId, String youtubeLink) async {
    final yt = YoutubeExplode();
    try {
      final videoId = VideoId.parse(youtubeLink);
      final video = await yt.videos.get(videoId);
      final title = video.title;
      final thumbnailUrl = video.thumbnails.mediumResUrl;

      final newLink = YoutubeLink(
        // Firestore will generate an ID, so we can pass an empty string or let it be handled by Firestore
        // For the model, 'id' is required, but it's mainly for when data is read back.
        // When creating, Firestore generates the doc ID which becomes 'id' in fromFirestore.
        // We can provide a temporary or placeholder if needed by the model structure before saving,
        // but it's not used by Firestore's add() method.
        // Let's assume the model's 'id' can be initialized empty or is not strictly needed before saving to Firestore.
        // If the model's 'id' field must be non-null even before saving, a temporary UUID could be generated here.
        // However, typical Firestore practice is that the ID is generated by Firestore upon adding.
        // The 'id' in the model is mostly for when you *read* data.
        // Let's pass an empty string for now, assuming the model handles it or it's ignored by toFirestore.
        id: '', // This will be overridden by Firestore's generated ID when read back.
        userId: userId,
        youtubeLink: youtubeLink,
        title: title,
        thumbnailUrl: thumbnailUrl,
        timestamp: FieldValue.serverTimestamp(),
      );

      await _linksRef.add(newLink);
    } catch (e) {
      // Log error or handle it as per application's error handling strategy
      print('Error adding YouTube link: $e');
      // Optionally rethrow or return a custom error status
      rethrow; // Rethrowing to let the caller know something went wrong
    } finally {
      yt.close();
    }
  }

  Stream<List<YoutubeLink>> getLinks(String userId) {
    return _linksRef
        .where('userId', isEqualTo: userId)
        .orderBy('timestamp', descending: true)
        .snapshots()
        .map((snapshot) =>
            snapshot.docs.map((doc) => doc.data()).toList());
  }

  Future<void> deleteLink(String documentId) async {
    try {
      await _linksRef.doc(documentId).delete();
    } catch (e) {
      // Log error or handle it
      print('Error deleting link: $e');
      rethrow;
    }
  }
}
